[{"id":0,"href":"/knitkit-doc/usage/","title":"Usage","parent":"KnitKit Documents","content":""},{"id":1,"href":"/knitkit-doc/usage/data-type/","title":"Data Types","parent":"Usage","content":"   Name Usage Description     UInt UInt(5.W) Unsigned Integer with 5-bit width   SInt SInt(3.W) Signed Integer with 3-bit width   Bool Bool() 1-bit unsigned integer, the same as UInt(1.W)    Literal    Constant or literal values are expressed using Scala integers or strings passed to constructors for the types:\nclass LitValue1 extends RawModule { val out1 = IO(Output(UInt(5.W))) val out2 = IO(Output(UInt(4.W))) val out3 = IO(Output(UInt(3.W))) val out4 = IO(Output(SInt(4.W))) val out5 = IO(Output(SInt(4.W))) val out6 = IO(Output(SInt(32.W))) val out7 = IO(Output(UInt(4.W))) val out8 = IO(Output(UInt(4.W))) val out9 = IO(Output(UInt(4.W))) val outB0 = IO(Output(Bool())) val outB1 = IO(Output(Bool())) val outB2 = IO(Output(Bool())) val outB3 = IO(Output(Bool())) /* inferred width according to LHS */ out1 := 1.U out3 := 5.U // unsigned 3-bit integer  out4 := 5.S // signed 4-bit integer  out5 := -8.S // negative decimal 4-bit literal  /* specified width */ out2 := 8.U(4.W) out6 := -152.S(32.W) // 32-bit signed decimal, value -152  /* string literals */ out7 := \u0026#34;ha\u0026#34;.U // hexadecimal 4-bit  out8 := \u0026#34;o12\u0026#34;.U // octal 4-bit lit from string  out9 := \u0026#34;b1010\u0026#34;.U // binary 4-bit lit from string  /* Boolean */ outB0 := true.B outB1 := false.B outB2 := 1.B outB3 := 0.B } Generated verilog as below:\nmodule LitValue1( output [4:0] out1, output [3:0] out2, output [2:0] out3, output [3:0] out4, output [3:0] out5, output [31:0] out6, output [3:0] out7, output [3:0] out8, output [3:0] out9, output outB0, output outB1, output outB2, output outB3 ); assign out1 = 5\u0026#39;h1; assign out2 = 4\u0026#39;h8; assign out3 = 3\u0026#39;h5; assign out4 = 4\u0026#39;sh5; assign out5 = -4\u0026#39;sh8; assign out6 = -32\u0026#39;sh98; assign out7 = 4\u0026#39;ha; assign out8 = 4\u0026#39;ha; assign out9 = 4\u0026#39;ha; assign outB0 = 1\u0026#39;h1; assign outB1 = 1\u0026#39;h0; assign outB2 = 1\u0026#39;h1; assign outB3 = 1\u0026#39;h0; endmodule The .asSInt and .asUInt for literal are the same as .S and .U.\nUnderscores can be used as separators in long string literals to aid readability, but are ignored when creating the value.\nclass LitValue2 extends RawModule { val out1 = IO(Output(UInt(32.W))) val out2 = IO(Output(UInt(8.W))) val out3 = IO(Output(UInt(6.W))) val out4 = IO(Output(UInt(12.W))) val out5 = IO(Output(SInt(7.W))) val out6 = IO(Output(UInt(8.W))) out1 := \u0026#34;h_dead_beef\u0026#34;.U // Underscores for readability  out2 := \u0026#34;ha\u0026#34;.asUInt(8.W) // hexadecimal 8-bit lit of type UInt  out3 := \u0026#34;o12\u0026#34;.asUInt(6.W) // octal 6-bit lit of type UInt  out4 := \u0026#34;b1010\u0026#34;.asUInt(12.W) // binary 12-bit lit of type UInt  out5 := 5.asSInt(7.W) // signed decimal 7-bit lit of type SInt  out6 := 5.asUInt(8.W) // unsigned decimal 8-bit lit of type UInt } Generated verilog as below:\nmodule LitValue2( output [31:0] out1, output [7:0] out2, output [5:0] out3, output [11:0] out4, output [6:0] out5, output [7:0] out6 ); assign out1 = 32\u0026#39;hdeadbeef; assign out2 = 8\u0026#39;ha; assign out3 = 6\u0026#39;ha; assign out4 = 12\u0026#39;ha; assign out5 = 7\u0026#39;sh5; assign out6 = 8\u0026#39;h5; endmodule asSInt and asUInt used for casting.\nclass Casting extends RawModule { val out0 = IO(Output(SInt(3.W))) val out1 = IO(Output(UInt(3.W))) val out2 = IO(Output(UInt(3.W))) out0 := 7.U.asSInt.asUInt.asSInt.asSInt out1 := -1.S(3.W).asUInt out2 := -1.S.asUInt } Generated verilog as below:\nmodule Casting( output [2:0] out0, output [2:0] out1, output [2:0] out2 ); assign out0 = -3\u0026#39;sh1; assign out1 = 3\u0026#39;h7; assign out2 = 3\u0026#39;h1; endmodule "},{"id":2,"href":"/knitkit-doc/usage/operators/","title":"Operators","parent":"Usage","content":"Bitwise operators       Operation Explanation     val invertedX = ~x Bitwise NOT   val hiBits = x \u0026amp; \u0026quot;h_ffff_0000\u0026quot;.U Bitwise AND   val OROut = flagsIn | overflow Bitwise OR   val XOROut = flagsIn ^ toggle Bitwise XOR    class Bitwise_Ops extends RawModule { val x = IO(Input(UInt(32.W))) val invertedX = IO(Output(UInt(32.W))) val hiBits = IO(Output(UInt(32.W))) val OROut = IO(Output(UInt(32.W))) val XOROut = IO(Output(UInt(32.W))) invertedX := ~x // Bitwise NOT  hiBits := x \u0026amp; \u0026#34;h_ffff_0000\u0026#34;.U // Bitwise AND  OROut := invertedX | hiBits // Bitwise OR  XOROut := invertedX ^ hiBits // Bitwise XOR } Generated verilog as below:\nmodule Bitwise_Ops( input [31:0] x, output [31:0] invertedX, output [31:0] hiBits, output [31:0] OROut, output [31:0] XOROut ); assign invertedX = ~ x; assign hiBits = x \u0026amp; 32\u0026#39;hffff0000; assign OROut = invertedX | hiBits; assign XOROut = invertedX ^ hiBits; endmodule Bitwise reductions       Operation Explanation     val allSet = x.andR AND reduction   val anySet = x.orR OR reduction   val parity = x.xorR XOR reduction    class Bitwise_Reductions extends RawModule { val x = IO(Input(UInt(32.W))) val allSet = IO(Output(Bool())) val anySet = IO(Output(Bool())) val parity = IO(Output(Bool())) allSet := x.andR anySet := x.orR parity := x.xorR } Generated verilog as below:\nmodule Bitwise_Reductions( input [31:0] x, output allSet, output anySet, output parity ); assign allSet = x == 32\u0026#39;hffffffff; assign anySet = x != 1\u0026#39;h0; assign parity = ^x; endmodule Equality comparison       Operation Explanation     val equ = x === y Equality   val neq = x =/= y Inequality    class Equality_Comparison extends RawModule { val x = IO(Input(UInt(5.W))) val y = IO(Input(UInt(4.W))) val equ = IO(Output(Bool())) val neq = IO(Output(Bool())) equ := x === y neq := x =/= y } Generated verilog as below:\nmodule Equality_Comparison( input [4:0] x, input [3:0] y, output equ, output neq ); assign equ = x == y; assign neq = x != y; endmodule Shifts       Operation Explanation     val twoToTheX = 1.S \u0026lt;\u0026lt; x Logical shift left   val hiBits = x \u0026gt;\u0026gt; 16.U Right shift (logical on UInt and arithmetic on SInt).    TODO: arithmetic on SInt\nclass Shifts extends RawModule { val x = IO(Input(UInt(3.W))) val y = IO(Input(UInt(32.W))) val twoToTheX = IO(Output(SInt(33.W))) val hiBits = IO(Output(UInt(16.W))) twoToTheX := (1.S \u0026lt;\u0026lt; x) hiBits := y \u0026gt;\u0026gt; 16.U } Generated verilog as below:\nmodule Shifts( input [2:0] x, input [31:0] y, output [32:0] twoToTheX, output [15:0] hiBits ); assign twoToTheX = $signed(2\u0026#39;sh1) \u0026lt;\u0026lt; x; assign hiBits = y \u0026gt;\u0026gt; 5\u0026#39;h10; endmodule Bitfield manipulation       Operation Explanation     val xLSB = x(0) Extract single bit, LSB has index 0.   val xTopNibble = x(15, 12) Extract bit field from end to start bit position.   val usDebt = Fill(3, \u0026quot;hA\u0026quot;.U) Replicate a bit string multiple times.   val float = Cat(sign, exponent, mantissa) Concatenates bit fields, with first argument on left.    class Bitfield_Manipulation extends RawModule { val sel = IO(Input(UInt(4.W))) val x = IO(Input(UInt(16.W))) val dynamicSel = IO(Output(Bool())) val xLSB = IO(Output(Bool())) val xTopNibble = IO(Output(UInt(4.W))) val usDebt = IO(Output(UInt(12.W))) val float = IO(Output(UInt(17.W))) dynamicSel := x(sel, \u0026#34;foo\u0026#34;) // foo used for naming intermediate variable.  xLSB := x(0) xTopNibble := x(15, 12) usDebt := Fill(3, \u0026#34;hA\u0026#34;.U) float := Cat(xLSB, xTopNibble, usDebt) } Generated verilog as below:\nmodule Bitfield_Manipulation( input [3:0] sel, input [15:0] x, output dynamicSel, output xLSB, output [3:0] xTopNibble, output [11:0] usDebt, output [16:0] float ); wire [15:0] foo; assign foo = x \u0026gt;\u0026gt; sel; assign dynamicSel = foo[0]; assign xLSB = x[0]; assign xTopNibble = x[15:12]; assign usDebt = {4\u0026#39;ha, 4\u0026#39;ha, 4\u0026#39;ha}; assign float = {xLSB, xTopNibble, usDebt}; endmodule Logical Operations       Operation Explanation     val sleep = !busy Logical NOT   val hit = tagMatch \u0026amp;\u0026amp; valid Logical AND   val stall = src1busy || src2busy Logical OR   val out = Mux(sel, inTrue, inFalse) Two-input mux where sel is a Bool    class Logical_Operations extends RawModule { val sel = IO(Input(Bool())) val a = IO(Input(Bool())) val b = IO(Input(Bool())) val sleep = IO(Output(Bool())) val hit = IO(Output(Bool())) val stall = IO(Output(Bool())) val out = IO(Output(Bool())) sleep := !a hit := a \u0026amp;\u0026amp; b stall := a || b out := Mux(sel, a, b) } Generated verilog as below:\nmodule Logical_Operations( input sel, input a, input b, output sleep, output hit, output stall, output out ); assign sleep = a == 1\u0026#39;h0; assign hit = a \u0026amp; b; assign stall = a | b; assign out = sel ? a : b; endmodule Arithmetic operations       Operation Explanation     val sum = a + b or val sum = a +% b Addition (without width expansion)   val diff = a - b or val diff = a -% b Subtraction (without width expansion)   val prod = a * b Multiplication   val div = a / b Division   val mod = a % b Modulus    class Arithmetic_Operations extends RawModule { val a = IO(Input(UInt(8.W))) val b = IO(Input(UInt(8.W))) val sum = IO(Output(UInt(8.W))) val diff0 = IO(Output(UInt(9.W))) val diff1 = IO(Output(UInt(9.W))) val diff2 = IO(Output(UInt(9.W))) val prod = IO(Output(UInt(16.W))) val div = IO(Output(UInt(8.W))) val mod = IO(Output(UInt(8.W))) sum := a + b diff0 := a - b prod := a * b div := a / b mod := a % b } Generated verilog as below:\nmodule Arithmetic_Operations( input [7:0] a, input [7:0] b, output [7:0] sum, output [8:0] diff0, output [8:0] diff1, output [8:0] diff2, output [15:0] prod, output [7:0] div, output [7:0] mod ); assign sum = a + b; assign diff0 = a - b; assign prod = a * b; assign div = a / b; assign mod = a % b; endmodule Arithmetic comparisons       Operation Explanation     val gt = a \u0026gt; b Greater than   val gte = a \u0026gt;= b Greater than or equal   val lt = a \u0026lt; b Less than   val lte = a \u0026lt;= b Less than or equal    class Arithmetic_Comparisons extends RawModule { val a = IO(Input(UInt(8.W))) val b = IO(Input(UInt(8.W))) val gt = IO(Output(Bool())) val gte = IO(Output(Bool())) val lt = IO(Output(Bool())) val lte = IO(Output(Bool())) gt := a \u0026gt; b gte := a \u0026gt;= b lt := a \u0026lt; b lte := a \u0026lt;= b } Generated verilog as below:\nmodule Arithmetic_Comparisons( input [7:0] a, input [7:0] b, output gt, output gte, output lt, output lte ); assign gt = a \u0026gt; b; assign gte = a \u0026gt;= b; assign lt = a \u0026lt; b; assign lte = a \u0026lt;= b; endmodule "},{"id":3,"href":"/knitkit-doc/usage/bundle/","title":"Bundle","parent":"Usage","content":"Bundle is Map-like data structure for knitkit ground type, the name of value in generated verilog file is the key name by default, but you can use suggestName change it.\nFor example:\nval io = IO(Bundle( \u0026#34;sign\u0026#34; -\u0026gt; Output(Bool()), \u0026#34;exponent\u0026#34; -\u0026gt; Bundle( \u0026#34;1\u0026#34; -\u0026gt; Output(UInt(8.W)), \u0026#34;2\u0026#34; -\u0026gt; Output(UInt(8.W)), ), \u0026#34;significand\u0026#34; -\u0026gt; Output(UInt(23.W)), )) Naming result should be:\n io_sign = Output(Bool()) io_exponent_1 = Output(UInt( 8.W)) io_exponent_2 = Output(UInt( 8.W)) io_significand = Output(UInt(23.W)) If use suggestName, for example:\nval io = IO(Bundle( \u0026#34;sign\u0026#34; -\u0026gt; Output(Bool()).suggestName(\u0026#34;foo\u0026#34;), \u0026#34;exponent\u0026#34; -\u0026gt; Bundle( \u0026#34;1\u0026#34; -\u0026gt; Output(UInt( 8.W)), \u0026#34;2\u0026#34; -\u0026gt; Output(UInt( 8.W)), ).suggestName(\u0026#34;bar\u0026#34;), \u0026#34;significand\u0026#34; -\u0026gt; Output(UInt(23.W)), )) suggestName only rename one key-level, not the whole. Naming result should be:\n io_foo = Output(Bool()) io_bar_1 = Output(UInt( 8.W)) io_bar_2 = Output(UInt( 8.W)) io_significand = Output(UInt(23.W)) A complete example as below:\nclass BundleCase extends RawModule { val io = IO(Bundle( \u0026#34;sign\u0026#34; -\u0026gt; Output(Bool()).suggestName(\u0026#34;foo\u0026#34;), \u0026#34;exponent\u0026#34; -\u0026gt; Bundle( \u0026#34;1\u0026#34; -\u0026gt; Output(UInt( 8.W)), \u0026#34;2\u0026#34; -\u0026gt; Output(UInt( 8.W)), ).suggestName(\u0026#34;bar\u0026#34;), \u0026#34;significand\u0026#34; -\u0026gt; Output(UInt(23.W)), )) val my_float = Bundle( \u0026#34;sign\u0026#34; -\u0026gt; Bool(), \u0026#34;exponent\u0026#34; -\u0026gt; UInt(8.W), \u0026#34;significand\u0026#34; -\u0026gt; UInt(23.W), ) // Floating point constant.  val floatConst = Wire(my_float) floatConst(\u0026#34;sign\u0026#34; ) := true.B floatConst(\u0026#34;exponent\u0026#34; ) := 10.U floatConst(\u0026#34;significand\u0026#34;) := 128.U io(\u0026#34;sign\u0026#34; ) := floatConst(\u0026#34;sign\u0026#34;) io(\u0026#34;exponent\u0026#34; )(\u0026#34;1\u0026#34;) := floatConst(\u0026#34;exponent\u0026#34;) io(\u0026#34;exponent\u0026#34; )(\u0026#34;2\u0026#34;) := floatConst(\u0026#34;exponent\u0026#34;) io(\u0026#34;significand\u0026#34;) := floatConst(\u0026#34;significand\u0026#34;) } Generated verilog as below:\nmodule BundleCase( output io_foo, output [7:0] io_bar_1, output [7:0] io_bar_2, output [22:0] io_significand ); wire floatConst_sign; wire [7:0] floatConst_exponent; wire [22:0] floatConst_significand; assign floatConst_sign = 1\u0026#39;h1; assign floatConst_exponent = 8\u0026#39;ha; assign floatConst_significand = 23\u0026#39;h80; assign io_foo = floatConst_sign; assign io_bar_1 = floatConst_exponent; assign io_bar_2 = floatConst_exponent; assign io_significand = floatConst_significand; endmodule Use asUInt convert Bundle to UInt, the first order in bundle as the Most Significant Bit.\npackage example package bundle import knitkit._ class AsUIntCase extends RawModule { val out = IO(Output(UInt(32.W))) val bundle = Wire(Bundle( \u0026#34;foo\u0026#34; -\u0026gt; UInt(16.W), \u0026#34;bar\u0026#34; -\u0026gt; UInt(16.W), )) bundle(\u0026#34;foo\u0026#34;) := 0x1234.U bundle(\u0026#34;bar\u0026#34;) := 0x5678.U out := bundle.asUInt } Generated verilog as below:\nmodule AsUIntCase( output [31:0] out ); wire [15:0] bundle_foo; wire [15:0] bundle_bar; assign bundle_foo = 16\u0026#39;h1234; assign bundle_bar = 16\u0026#39;h5678; assign out = {bundle_foo, bundle_bar}; endmodule Use \u0026lt;\u0026gt; to connect Bundle\nclass PacketCase extends RawModule { val packet = Seq( \u0026#34;header\u0026#34; -\u0026gt; UInt(16.W), \u0026#34;addr\u0026#34; -\u0026gt; UInt(16.W), \u0026#34;data\u0026#34; -\u0026gt; UInt(32.W), ) val io = IO(Bundle( \u0026#34;inPacket\u0026#34; -\u0026gt; Input (Bundle(packet)), \u0026#34;outPacket\u0026#34; -\u0026gt; Output(Bundle(packet)), )) val reg = Wire(Bundle(packet)) reg \u0026lt;\u0026gt; io(\u0026#34;inPacket\u0026#34;) reg \u0026lt;\u0026gt; io(\u0026#34;outPacket\u0026#34;) io(\u0026#34;inPacket\u0026#34;) \u0026lt;\u0026gt; io(\u0026#34;outPacket\u0026#34;) } Generated verilog as below:\nmodule PacketCase(input [15:0] io_inPacket_header, input [15:0] io_inPacket_addr, input [31:0] io_inPacket_data, output [15:0] io_outPacket_header, output [15:0] io_outPacket_addr, output [31:0] io_outPacket_data ); wire [15:0] reg_header; wire [15:0] reg_addr; wire [31:0] reg_data; assign reg_header = io_inPacket_header; assign reg_addr = io_inPacket_addr; assign reg_data = io_inPacket_data; assign io_outPacket_header = reg_header; assign io_outPacket_addr = reg_addr; assign io_outPacket_data = reg_data; assign io_outPacket_header = io_inPacket_header; assign io_outPacket_addr = io_inPacket_addr; assign io_outPacket_data = io_inPacket_data; endmodule TODO: Flipping Bundles\nclass ABBundle extends Bundle { val a = Input(Bool()) val b = Output(Bool()) } class MyFlippedModule extends RawModule { // Normal instantiation of the bundle  // \u0026#39;a\u0026#39; is an Input and \u0026#39;b\u0026#39; is an Output  val normalBundle = IO(new ABBundle) normalBundle.b := normalBundle.a // Flipped recursively flips the direction of all Bundle fields  // Now \u0026#39;a\u0026#39; is an Output and \u0026#39;b\u0026#39; is an Input  val flippedBundle = IO(Flipped(new ABBundle)) flippedBundle.a := flippedBundle.b } Generated verilog as below:\nmodule MyFlippedModule( input normalBundle_a, output normalBundle_b, output flippedBundle_a, input flippedBundle_b ); assign normalBundle_b = normalBundle_a; // @[bundles-and-vecs.md 61:18]  assign flippedBundle_a = flippedBundle_b; // @[bundles-and-vecs.md 66:19] endmodule "},{"id":4,"href":"/knitkit-doc/usage/reg-wire/","title":"Combinational and Sequential Circuits","parent":"Usage","content":"    Wire Register  Reg Example Register Width Inference Example Register Initialize Example Register Initialize by Other Variable Example Register Initialize by other variable Example 2 Register Initialized Inferred Width by Literal Example Register Initialize Bundle Example Register Delayed by One Clock Cycle RegNextInit       Wire    Wires as hardware nodes to which one can assign values or connect other nodes.\nclass WireCase extends RawModule { val out1 = IO(Output(UInt(8.W))) val out2 = IO(Output(UInt(8.W))) val my_node = Wire(UInt(8.W)) my_node := 10.U val init_node = WireInit(10.U(8.W)) out1 := my_node out2 := init_node } Generated verilog as below:\nmodule WireCase( output [7:0] out1, output [7:0] out2 ); wire [7:0] my_node; wire [7:0] init_node; assign my_node = 8\u0026#39;ha; assign init_node = 8\u0026#39;ha; assign out1 = my_node; assign out2 = init_node; endmodule Register    Reg Example    Register with Clock.\nclass RegCase extends RawModule { val clk = IO(Input(Clock())) val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val delayReg = withClock(clk) { Reg(UInt(3.W)) } delayReg := in out := delayReg } Generated verilog as below:\nmodule RegCase( input clk, input [2:0] in, output [2:0] out ); reg [2:0] delayReg; assign out = delayReg; always @(posedge clk) begin delayReg \u0026lt;= in; end endmodule Register Width Inference Example    Register unspecified widths will be inferred by the value assigned to it.\nclass RegInferredCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val delayReg = withClock(clk) { Reg(UInt()) } delayReg := in out := delayReg } Generated verilog as below:\nmodule RegInferredCase( input clk, input rst, input [2:0] in, output [2:0] out ); reg [2:0] delayReg; assign out = delayReg; always @(posedge clk) begin delayReg =\u0026gt; in; end endmodule Register with Clock and Synchronous Reset/AsyncNegReset/AsyncPosReset.\nRegister Initialize Example    Register initialized depends on its reset\u0026rsquo;s type: synchronous, asynchronous posedge/negedge.\nclass RegInitCase extends RawModule { val clk_1 = IO(Input(Clock())) val rst_1 = IO(Input(Reset())) val clk_2 = IO(Input(Clock())) val rst_2 = IO(Input(AsyncNegReset())) val clk_3 = IO(Input(Clock())) val rst_3 = IO(Input(AsyncPosReset())) val foo = IO(Input(UInt(3.W))) val bar = IO(Input(UInt(3.W))) val cat = IO(Input(UInt(3.W))) val foo_out = IO(Output(UInt(3.W))) val bar_out = IO(Output(UInt(3.W))) val cat_out = IO(Output(UInt(3.W))) val reg_foo = withClockAndReset(clk_1, rst_1) { RegInit(0.U(3.W)) } val reg_bar = withClockAndReset(clk_2, rst_2) { RegInit(0.U(3.W)) } val reg_cat = withClockAndReset(clk_3, rst_3) { RegInit(0.U(3.W)) } reg_foo := foo reg_bar := bar reg_cat := cat foo_out := reg_foo bar_out := reg_bar cat_out := reg_cat } Generated verilog as below:\nmodule RegInitCase( input clk_1, input rst_1, input clk_2, input rst_2, input clk_3, input rst_3, input [2:0] foo, input [2:0] bar, input [2:0] cat, output [2:0] foo_out, output [2:0] bar_out, output [2:0] cat_out ); reg [2:0] reg_foo; reg [2:0] reg_bar; reg [2:0] reg_cat; assign foo_out = reg_foo; assign bar_out = reg_bar; assign cat_out = reg_cat; always @(posedge clk_1) begin if (rst_1) begin reg_foo =\u0026gt; 3\u0026#39;h0; end else begin reg_foo =\u0026gt; foo; end end always @(posedge clk_2 or negedge rst_2) begin if (!rst_2) begin reg_bar =\u0026gt; 3\u0026#39;h0; end else begin reg_bar =\u0026gt; bar; end end always @(posedge clk_3 or posedge rst_3) begin if (rst_3) begin reg_cat =\u0026gt; 3\u0026#39;h0; end else begin reg_cat =\u0026gt; cat; end end endmodule Register Initialize by Other Variable Example    RegInit specify a type and another variable.\nclass RegInitDoubleArgCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val x_init = IO(Input(UInt(3.W))) val y_init = IO(Input(UInt(8.W))) val x_in = IO(Input(UInt(3.W))) val y_in = IO(Input(UInt(8.W))) val x_out = IO(Output(UInt(3.W))) val y_out = IO(Output(UInt(8.W))) val x = Wire(UInt()) val y = Wire(UInt(8.W)) val r1 = withClockAndReset(clk, rst) { RegInit(UInt(), x) } // width will be inferred to be 3  val r2 = withClockAndReset(clk, rst) { RegInit(UInt(8.W), y) } // width is set to 8  x := x_init y := y_init r1 := x_in r2 := y_in x_out := r1 y_out := r2 } Generated verilog as below:\nmodule RegInitDoubleArgCase( input clk, input rst, input [2:0] x_init, input [7:0] y_init, input [2:0] x_in, input [7:0] y_in, output [2:0] x_out, output [7:0] y_out ); wire [2:0] x; wire [7:0] y; reg [2:0] r1; reg [7:0] r2; assign x = x_init; assign y = y_init; assign x_out = r1; assign y_out = r2; always @(posedge clk) begin if (rst) begin r1 =\u0026gt; x; end else begin r1 =\u0026gt; x_in; end end always @(posedge clk) begin if (rst) begin r2 =\u0026gt; y; end else begin r2 =\u0026gt; y_in; end end endmodule Register Initialize by other variable Example 2    RegInit initialized by specifing another variable directly.\nclass RegInitInferredNonLitCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val x_init = IO(Input(UInt(3.W))) val y_init = IO(Input(UInt(8.W))) val x_in = IO(Input(UInt(3.W))) val y_in = IO(Input(UInt(8.W))) val x_out = IO(Output(UInt(3.W))) val y_out = IO(Output(UInt(8.W))) val x = Wire(UInt()) val y = Wire(UInt(8.W)) val r1 = withClockAndReset(clk, rst) { RegInit(x) } // width will be inferred to be 3  val r2 = withClockAndReset(clk, rst) { RegInit(y) } // width is set to 8  x := x_init y := y_init r1 := x_in r2 := y_in x_out := r1 y_out := r2 } Generated verilog as below:\nmodule RegInitInferredNonLitCase( input clk, input rst, input [2:0] x_init, input [7:0] y_init, input [2:0] x_in, input [7:0] y_in, output [2:0] x_out, output [7:0] y_out ); wire [2:0] x; wire [7:0] y; reg [2:0] r1; reg [7:0] r2; assign x = x_init; assign y = y_init; assign x_out = r1; assign y_out = r2; always @(posedge clk) begin if (rst) begin r1 =\u0026gt; x; end else begin r1 =\u0026gt; x_in; end end always @(posedge clk) begin if (rst) begin r2 =\u0026gt; y; end else begin r2 =\u0026gt; y_in; end end endmodule Register Initialized Inferred Width by Literal Example    Register\u0026rsquo;s initialized width can be inferred by literal.\nclass RegInitInferredLitCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val x_in = IO(Input(UInt(3.W))) val y_in = IO(Input(UInt(8.W))) val x_out = IO(Output(UInt(3.W))) val y_out = IO(Output(UInt(8.W))) val x = withClockAndReset(clk, rst) { RegInit(5.U) } // width will be inferred to be 3  val y = withClockAndReset(clk, rst) { RegInit(5.U(8.W)) } // width is set to 8  x := x_in y := y_in x_out := x y_out := y } Generated verilog as below:\nmodule RegInitInferredLitCase( input clk, input rst, input [2:0] x_in, input [7:0] y_in, output [2:0] x_out, output [7:0] y_out ); reg [2:0] x; reg [7:0] y; assign x_out = x; assign y_out = y; always @(posedge clk) begin if (rst) begin x =\u0026gt; 3\u0026#39;h5; end else begin x =\u0026gt; x_in; end end always @(posedge clk) begin if (rst) begin y =\u0026gt; 8\u0026#39;h5; end else begin y =\u0026gt; y_in; end end endmodule Register Initialize Bundle Example    Bundle of registers can\u0026rsquo;t initialized once.\nclass RegInitInferredAggCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val x_init = IO(Input(UInt(3.W))) val y_init = IO(Input(UInt(8.W))) val x_in = IO(Input(UInt(3.W))) val y_in = IO(Input(UInt(8.W))) val x_out = IO(Output(UInt(3.W))) val y_out = IO(Output(UInt(8.W))) val bundle = Wire(Bundle( \u0026#34;x\u0026#34; -\u0026gt; UInt(), \u0026#34;y\u0026#34; -\u0026gt; UInt(8.W), )) val r = withClockAndReset(clk, rst) { RegInit(bundle) } bundle(\u0026#34;x\u0026#34;) := x_init bundle(\u0026#34;y\u0026#34;) := y_init r(\u0026#34;x\u0026#34;) := x_in r(\u0026#34;y\u0026#34;) := y_in x_out := r(\u0026#34;x\u0026#34;) y_out := r(\u0026#34;y\u0026#34;) } Generated verilog as below:\nmodule RegInitInferredAggCase( input clk, input rst, input [2:0] x_init, input [7:0] y_init, input [2:0] x_in, input [7:0] y_in, output [2:0] x_out, output [7:0] y_out ); wire [2:0] bundle_x; wire [7:0] bundle_y; reg [2:0] r_x; reg [7:0] r_y; assign bundle_x = x_init; assign bundle_y = y_init; assign x_out = r_x; assign y_out = r_y; always @(posedge clk) begin if (rst) begin r_x =\u0026gt; bundle_x; end else begin r_x =\u0026gt; x_in; end end always @(posedge clk) begin if (rst) begin r_y =\u0026gt; bundle_y; end else begin r_y =\u0026gt; y_in; end end endmodule Register Delayed by One Clock Cycle    RegNext generate a register delayed by on clock cycle.\nclass RegNextCase extends RawModule { val clk = IO(Input(Clock())) val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val delayReg = withClock(clk) { RegNext(in) } out := delayReg } Generated verilog as below:\nmodule RegNextCase( input clk, input [2:0] in, output [2:0] out ); reg [2:0] delayReg; assign out = delayReg; always @(posedge clk) begin delayReg =\u0026gt; in; end endmodule RegNextInit    class RegNextInitCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val delayReg = withClockAndReset(clk, rst) { RegNext(in, 0.U(3.W)) } out := delayReg } Generated verilog as below:\nmodule RegNextCase( input clk, input [2:0] in, output [2:0] out ); reg [2:0] delayReg; assign out = delayReg; always @(posedge clk) begin delayReg =\u0026gt; in; end endmodule "},{"id":5,"href":"/knitkit-doc/usage/conditional/","title":"Conditional","parent":"Usage","content":"    When Statement  When Example ElseWhen Example Otherwise Example   Switch Statement  Enum as Conditional Literal as Conditional       When Statement    when, elsewhen and otherwise are similar to if, else if and else.\nDepends on variable\u0026rsquo;s type, generating different always block:\n   Variable type Generated Block     wire always @(*)   register synchronous reset always @(posedge clock)   register asynchronous reset at posedge always @(posedge clock or posedge reset)   register asynchronous reset at negedge always @(posedge clock or negedge reset)    When Example    class WhenCase extends RawModule { val clk = IO(Input(Clock())) setClock(clk) val sel1 = IO(Input(Bool())) val sel2 = IO(Input(Bool())) val out1 = IO(Output(UInt(3.W))) val out2 = IO(Output(UInt(3.W))) val foo = Wire(UInt(3.W)) val bar = Reg(UInt(3.W)) foo := 2.U when (sel1) { foo := 5.U } bar := 4.U when (sel2) { bar := 3.U } out1 := foo out2 := bar } Generated verilog as below:\nmodule WhenCase( input clk, input sel1, input sel2, output [2:0] out1, output [2:0] out2 ); wire [2:0] foo; reg [2:0] bar; assign foo = 3\u0026#39;h2; assign out1 = foo; assign out2 = bar; always @(*) begin if (sel1) begin foo \u0026lt;= 3\u0026#39;h5; end end always @(posedge clk) begin if (sel2) begin bar \u0026lt;= 3\u0026#39;h3; end bar \u0026lt;= 3\u0026#39;h4; end endmodule ElseWhen Example    class ElseWhenCase extends RawModule { val clk = IO(Input(Clock())) setClock(clk) val foo_sel1 = IO(Input(Bool())) val foo_sel2 = IO(Input(Bool())) val bar_sel1 = IO(Input(Bool())) val bar_sel2 = IO(Input(Bool())) val out1 = IO(Output(UInt(3.W))) val out2 = IO(Output(UInt(3.W))) val foo = Wire(UInt(3.W)) val bar = Reg(UInt(3.W)) foo := 0.U when (foo_sel1) { foo := 5.U } .elsewhen (foo_sel2) { foo := 4.U } bar := 0.U when (bar_sel1) { bar := 3.U } .elsewhen (bar_sel2) { bar := 2.U } out1 := foo out2 := bar } Generated verilog as below:\nmodule ElseWhenCase( input clk, input foo_sel1, input foo_sel2, input bar_sel1, input bar_sel2, output [2:0] out1, output [2:0] out2 ); wire [2:0] foo; reg [2:0] bar; assign foo = 3\u0026#39;h0; assign out1 = foo; assign out2 = bar; always @(*) begin if (foo_sel1) begin foo \u0026lt;= 3\u0026#39;h5; end else if (foo_sel2) begin foo \u0026lt;= 3\u0026#39;h4; end end always @(posedge clk) begin if (bar_sel1) begin bar \u0026lt;= 3\u0026#39;h3; end else if (bar_sel2) begin bar \u0026lt;= 3\u0026#39;h2; end bar \u0026lt;= 3\u0026#39;h0; end endmodule Otherwise Example    class OtherwiseCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) setClockAndReset(clk, rst) val sel1 = IO(Input(Bool())) val sel2 = IO(Input(Bool())) val out1 = IO(Output(UInt(3.W))) val out2 = IO(Output(UInt(3.W))) val out3 = IO(Output(UInt(4.W))) val foo = Wire(UInt(3.W)) val bar = Reg(UInt(3.W)) val car = RegInit(14.U(4.W)) foo := 1.U when (sel1) { foo := 5.U when (sel2) { foo := 7.U } } otherwise { foo := 2.U } bar := 2.U when (sel2) { bar := 3.U } otherwise { bar := 4.U } car := 1.U when (sel2) { car := 2.U } .elsewhen(sel1) { car := 3.U } otherwise { car := 4.U } out1 := foo out2 := bar out3 := car } Generated verilog as below:\nmodule OtherwiseCase( input clk, input rst, input sel1, input sel2, output [2:0] out1, output [2:0] out2, output [3:0] out3 ); wire [2:0] foo; reg [2:0] bar; reg [3:0] car; assign foo = 3\u0026#39;h1; assign out1 = foo; assign out2 = bar; assign out3 = car; always @(*) begin if (sel1) begin foo \u0026lt;= 3\u0026#39;h5; if (sel2) begin foo \u0026lt;= 3\u0026#39;h7; end end else begin foo \u0026lt;= 3\u0026#39;h2; end end always @(posedge clk) begin if (sel2) begin bar \u0026lt;= 3\u0026#39;h3; end else begin bar \u0026lt;= 3\u0026#39;h4; end bar \u0026lt;= 3\u0026#39;h2; end always @(posedge clk) begin if (rst) begin car =\u0026gt; 4\u0026#39;he; end else if (sel2) begin car \u0026lt;= 4\u0026#39;h2; end else if (sel1) begin car \u0026lt;= 4\u0026#39;h3; end else begin car \u0026lt;= 4\u0026#39;h4; end car \u0026lt;= 4\u0026#39;h1; end endmodule Switch Statement    switch statements is similar to case statements in verilog.\nswtich (case_expr) { is(condition1) { true_statement1 } is(condition2) { true_statement2 } ... default { default_statement } } is similar to:\ncase(case_expr) condition1 : true_statement1 ; condition2 : true_statement2 ; ... default : default_statement ; endcase Enum as Conditional    val state_on :: state_off :: Nil = Enum(2) create two constants with name, from left to right represent 0, 1 and so on. It easily is used as condition.\nclass SwitchCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) setClockAndReset(clk, rst) val in = IO(Input(UInt(1.W))) val out = IO(Output(UInt(2.W))) val out_num = IO(Output(UInt(3.W))) val reg = Reg(UInt(3.W)) val state_on :: state_off :: Nil = Enum(2) val state = RegInit(state_on) state := in out_num := reg swtich (state) { is (state_on) { out := 1.U reg := 2.U } is (state_off) { out := 3.U reg := 4.U } default { out := 0.U reg := 0.U } } } Generated verilog as below:\nmodule SwitchCase( input clk, input rst, input in, output [1:0] out, output [2:0] out_num ); reg [2:0] reg; reg state; assign out_num = reg; always @(posedge clk) begin if (rst) begin state =\u0026gt; 1\u0026#39;h0; end else begin state =\u0026gt; in; end end always @(*) begin case (state) 1\u0026#39;h0: //state_on  out =\u0026gt; 2\u0026#39;h1; 1\u0026#39;h1: //state_off  out =\u0026gt; 2\u0026#39;h3; default: out =\u0026gt; 2\u0026#39;h0; endcase //state  end always @(posedge clk) begin case (state) 1\u0026#39;h0: //state_on  reg =\u0026gt; 3\u0026#39;h2; 1\u0026#39;h1: //state_off  reg =\u0026gt; 3\u0026#39;h4; default: reg =\u0026gt; 3\u0026#39;h0; endcase //state  end endmodule Literal as Conditional    Use literal as condition value:\nclass SwitchLitCase extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) setClockAndReset(clk, rst) val in = IO(Input(UInt(1.W))) val out = IO(Output(UInt(2.W))) val out_num = IO(Output(UInt(3.W))) val reg = Reg(UInt(3.W)) val state = RegInit(0.U) state := in out_num := reg swtich (state) { is (0.U) { out := 1.U reg := 2.U } is (1.U) { out := 3.U reg := 4.U } default { out := 0.U reg := 0.U } } } Generated verilog as below:\nmodule SwitchLitCase( input clk, input rst, input in, output [1:0] out, output [2:0] out_num ); reg [2:0] reg; reg state; assign out_num = reg; always @(posedge clk) begin if (rst) begin state =\u0026gt; 1\u0026#39;h0; end else begin state =\u0026gt; in; end end always @(*) begin case (state) 1\u0026#39;h0: out =\u0026gt; 2\u0026#39;h1; 1\u0026#39;h1: out =\u0026gt; 2\u0026#39;h3; default: out =\u0026gt; 2\u0026#39;h0; endcase //state  end always @(posedge clk) begin case (state) 1\u0026#39;h0: reg =\u0026gt; 3\u0026#39;h2; 1\u0026#39;h1: reg =\u0026gt; 3\u0026#39;h4; default: reg =\u0026gt; 3\u0026#39;h0; endcase //state  end endmodule "},{"id":6,"href":"/knitkit-doc/usage/blackbox/","title":"BlackBox","parent":"Usage","content":"  BlackBoxes are used to instantiate externally defined modules. This construct is useful for hardware constructs that cannot be described in Scala and for connecting to FPGA or other IP not defined in\nclass IBUFDS extends BlackBox ( Map( \u0026#34;DIFF_TERM\u0026#34; -\u0026gt; \u0026#34;TRUE\u0026#34;, \u0026#34;IOSTANDARD\u0026#34; -\u0026gt; \u0026#34;DEFAULT\u0026#34; ) ) { val O = IO(Output(Clock())) val I = IO(Input(Clock())) val IB = IO(Input(Clock())) } class IBUF extends BlackBox { val O = IO(Output(Clock())) val I = IO(Input(Clock())) val IB = IO(Input(Clock())) } class BlackBoxCase extends RawModule { val clk_125M = IO(Input(Clock())) val clk_25M = IO(Input(Clock())) val sel = IO(Input(Bool())) val clk_out = IO(Output(Clock())) val ibufds = Module(new IBUFDS) val ibuf = Module(new IBUF ) val u_ibufds = ibufds.genInst() val u_ibuf = ibuf.genInst() u_ibufds(\u0026#34;I\u0026#34; ) \u0026lt;\u0026gt; clk_125M u_ibufds(\u0026#34;IB\u0026#34;) \u0026lt;\u0026gt; clk_25M u_ibuf(\u0026#34;I\u0026#34; ) \u0026lt;\u0026gt; clk_125M u_ibuf(\u0026#34;IB\u0026#34;) \u0026lt;\u0026gt; clk_25M clk_out := Mux(sel, u_ibufds(\u0026#34;O\u0026#34;), u_ibuf(\u0026#34;O\u0026#34;)) } Generated verilog as below:\nmodule BlackBoxCase( input clk_125M, input clk_25M, input sel, output clk_out ); wire u_ibufds_O; wire u_ibuf_O; IBUFDS #(.DIFF_TERM(\u0026#34;TRUE\u0026#34;), .IOSTANDARD(\u0026#34;DEFAULT\u0026#34;)) u_ibufds ( .IB (clk_25M ), .I (clk_125M ), .O (u_ibufds_O) ); IBUF u_ibuf ( .IB (clk_25M ), .I (clk_125M), .O (u_ibuf_O) ); assign clk_out = sel ? u_ibufds_O : u_ibuf_O; endmodule "},{"id":7,"href":"/knitkit-doc/usage/module-hierarchy/","title":"Module Hierarchy","parent":"Usage","content":"  Module\u0026rsquo;s declaration and submodule instantiation are two steps.\nIf defines a module Mux2, use val mux2_1 = Module(new Mux2(1)) as declaration, val m0 = mux2_1() to instantiate submodule.\nUse map-like\u0026rsquo;s method to reference submodule\u0026rsquo;s port. val sel defines in module Mux2, use m0(\u0026quot;sel\u0026quot;) to reference port sel.\nclass Mux2(width: Int) extends RawModule { override def desiredName = s\u0026#34;Mux2_${width}\u0026#34; val sel = IO(Input(UInt(1.W))) val in0 = IO(Input(UInt(width.W))) val in1 = IO(Input(UInt(width.W))) val out = IO(Output(UInt(width.W))) out := Mux(sel, in1, in0) } class Mux4 extends RawModule { val in0 = IO(Input (UInt(1.W))) val in1 = IO(Input (UInt(1.W))) val in2 = IO(Input (UInt(1.W))) val in3 = IO(Input (UInt(1.W))) val sel = IO(Input (UInt(2.W))) val out = IO(Output(UInt(2.W))) val mux2_1 = Module(new Mux2(1)) val mux2_2 = Module(new Mux2(2)) val m0 = mux2_1() m0(\u0026#34;sel\u0026#34;) := sel(0) m0(\u0026#34;in0\u0026#34;) := in0 m0(\u0026#34;in1\u0026#34;) := in1 val m1 = mux2_1() m1(\u0026#34;sel\u0026#34;) := sel(0) m1(\u0026#34;in0\u0026#34;) := in2 m1(\u0026#34;in1\u0026#34;) := in3 val m2 = mux2_2() m2(\u0026#34;sel\u0026#34;) := sel(1) val m2_in0 = WireInit(Cat(m0(\u0026#34;out\u0026#34;), m1(\u0026#34;out\u0026#34;))) m2(\u0026#34;in0\u0026#34;) := m2_in0 m2(\u0026#34;in1\u0026#34;) := Cat(m1(\u0026#34;out\u0026#34;), m0(\u0026#34;out\u0026#34;)) out := m2(\u0026#34;out\u0026#34;) } Generated verilog as below:\nmodule WireCase( output [7:0] out1, output [7:0] out2 ); wire [7:0] my_node; wire [7:0] init_node; assign my_node = 8\u0026#39;ha; assign init_node = 8\u0026#39;ha; assign out1 = my_node; assign out2 = init_node; endmodule module Mux2_1( input sel, input in0, input in1, output out ); assign out = sel ? in1 : in0; endmodule module Mux2_2( input sel, input [1:0] in0, input [1:0] in1, output [1:0] out ); assign out = sel ? in1 : in0; endmodule module Mux4( input in0, input in1, input in2, input in3, input [1:0] sel, output [1:0] out ); wire m0_out; wire m1_out; wire [1:0] m2_in0; Mux2_1 m0 ( .in0 (in0 ), .in1 (in1 ), .out (m0_out), .sel (sel[0]) ); Mux2_1 m1 ( .in0 (in2 ), .in1 (in3 ), .out (m1_out), .sel (sel[0]) ); Mux2_2 m2 ( .in0 (m2_in0 ), .in1 ({m1_out, m0_out}), .out (out ), .sel (sel[1] ) ); assign m2_in0 = {m0_out, m1_out}; endmodule "},{"id":8,"href":"/knitkit-doc/categories/","title":"Categories","parent":"KnitKit Documents","content":""},{"id":9,"href":"/knitkit-doc/usage/getting-started/","title":"Getting Started","parent":"Usage","content":"This page tells you how to get started with the KnitKit, including installation and default configuration.\n   Install requirements Project Directory Structure Simple Case     Install requirements    Install KnitKit with following shell command, if you would like to install it to system, use sudo and remove --user.\n# require Python versions: 3.6+ $ pip3 --user install knitkit Project Directory Structure    .knitkit: mill build tool and dependencies for building knitkit.\ndoc : Documents, default is empty.\nhw: hardware relatived files, default including rtl for verilog files, knitkit for scala project files.\nMakefile: Project Makefile, default including knitkit generation steps.\n. ├── .knitkit │ └── knitkit | ├── .cache │ ├── jars │ │ └── knitkit.jar │ └── mill ├── doc ├── hw │ ├── knitkit │ │ ├── build.sc │ │ └── src │ │ └── Main.scala │ └── rtl │── Makefile Simple Case    hw/knitkit/src/Main.scala demonstrates a 2-to-1 multiplexer.\nclass Mux2 extends RawModule { val sel = IO(Input(UInt(1.W))) val in0 = IO(Input(UInt(1.W))) val in1 = IO(Input(UInt(1.W))) val out = IO(Output(UInt(1.W))) out := (sel \u0026amp; in1) | (~sel \u0026amp; in0) } Type make verilog to generate verilog builds/Mux2.v:\nmodule Mux2( input sel, input in0, input in1, output out ); assign out = (sel \u0026amp; in1) | ((~ sel) \u0026amp; in0); endmodule "},{"id":10,"href":"/knitkit-doc/","title":"KnitKit Documents","parent":"","content":""},{"id":11,"href":"/knitkit-doc/tags/","title":"Tags","parent":"KnitKit Documents","content":""}]